% !TeX encoding = windows-1251
\section{Проектирование архитектуры приложения для знакомств}

\subsection{Проектирование архитектуры мобильного приложения}

Проектирование архитектуры мобильного приложения было выполнено на основе системного анализа предполагаемой функциональности, пользовательских сценариев и требований к масштабируемости. Приложение реализуется как клиентская часть, взаимодействующая с сервером через REST API, и играет роль интерфейса между конечным пользователем и рекомендательной системой.

Архитектура приложения строится вокруг концепции модулярности и разделения ответственности. Это означает, что каждый экран и компонент реализует строго определённую роль, что упрощает тестирование, расширение и поддержку.

В качестве основного навигационного каркаса был выбран стек навигации с возможностью модального перехода, поскольку пользователи часто выполняют действия в глубину (например, редактирование профиля, просмотр чужих профилей, переход в чат) с последующим возвратом к предыдущему контексту.

Начальной точкой проектирования стало обеспечение контроля доступа и персонализации взаимодействия. Приложение начинается с экрана входа, где пользователь может авторизоваться или зарегистрироваться. Выбор между этими ветками предопределяет дальнейший маршрут в навигации.

На рисунке \ref{fig:login_flow} представлена схема, иллюстрирующая данный процесс. При регистрации пользователь предоставляет базовую информацию (имя пользователя, пол, краткое описание), которая сохраняется на сервере и может быть использована как часть признаков в системе рекомендаций.

{
	\centering
	\includegraphics[width=0.7\linewidth]{login_flow.jpg}
	\captionof{figure}{Процесс входа и регистрации}
	\label{fig:login_flow}
}


Каждому пользователю доступен экран профиля, где отображается личная информация. В процессе проектирования было определено, что взаимодействие с профилем должно быть двухуровневым: просмотр и редактирование. Таким образом, экран <<Профиль>> реализован как статическое представление данных, а редактирование (аватара и описания) выполняется через отдельные маршруты. Это позволяет минимизировать когнитивную нагрузку и избежать случайных изменений.

На рисунке \ref{fig:profile_flow} показаны возможные действия пользователя с личным профилем. Архитектурно, экран реализован как обособленный компонент, который получает и обновляет данные через API, сохраняя локальное состояние до момента отправки изменений.

{
	\centering
	\includegraphics[width=0.8\linewidth]{profile_flow.jpg}
	\captionof{figure}{Редактирование профиля и выход}
	\label{fig:profile_flow}
}

Сердцем рекомендательной системы является вектор признаков, формируемый из ответов пользователя на серию вопросов. Было принято решение реализовать интерфейс прохождения теста через свайпы, поскольку это сочетает простоту использования и скорость. Такой формат также является привычным для пользователей в контексте приложений знакомств.

Как показано на рисунке \ref{fig:swipe_flow}, пользователь выбирает категорию, после чего отображается последовательность карточек с вопросами. Ответ осуществляется свайпом влево (отрицательный ответ), вправо (положительный) или вверх (нейтральный). При достижении конца набора карточек приложение сообщает об этом. В архитектуре эта часть реализована как отдельный модуль с локальным буфером вопросов, загружаемых с сервера по категориям.

{
	\centering
	\includegraphics[width=1\linewidth]{swipe_flow.jpg}
	\captionof{figure}{Процесс ответов на вопросы}
	\label{fig:swipe_flow}
}

На основе сформированных векторов признаков сервер предоставляет список пользователей, наиболее близких по сходству. Эта информация отображается на экране рекомендаций. Данный экран проектировался как динамическая таблица, получающая данные из внешнего источника с возможностью фильтрации и сортировки.

Как показано на рисунке \ref{fig:people_flow}, каждая карточка рекомендации предоставляет краткую информацию: имя, сходство и кнопку для запроса на чат. Нажатие на карточку открывает модальное окно с расширенным профилем. Эта структура проектировалась для поддержки масштабируемости — при появлении новых фильтров или параметров сортировки можно расширить интерфейс без изменения существующего кода отображения.

{
	\centering
	\includegraphics[width=1\linewidth]{people_flow.jpg}
	\captionof{figure}{Рекомендации, просмотр профиля и отправка запроса}
	\label{fig:people_flow}
}

Переход от рекомендаций к активному взаимодействию осуществляется через систему запросов на чат. С точки зрения архитектуры, чат требует наличия согласия двух сторон. Для этого реализован модуль управления заявками (Рисунок \ref{fig:messenger_flow}), в котором разделены входящие запросы и активные чаты.

Входящие запросы представлены в виде списка с возможностью принятия или отклонения. Принятые запросы автоматически перемещаются в раздел активных чатов. Таким образом, логика работы с чатами разделена на два уровня: согласование и непосредственное общение.

{
	\centering
	\includegraphics[width=0.9\linewidth]{messenger_flow.jpg}
	\captionof{figure}{Управление чатами и запросами на чат}
	\label{fig:messenger_flow}
}

Чат реализован как асинхронный поток сообщений. Было принято архитектурное решение о поддержке мультимедиа, что потребовало внедрения системы предварительного просмотра и управления прикреплёнными файлами. На рисунке \ref{fig:chat_flow} представлена логика интерфейса: отправка текста и вложений.

{
	\centering
	\includegraphics[width=0.85\linewidth]{chat_flow.jpg}
	\captionof{figure}{Функционал чата: отправка сообщений и медиа}
	\label{fig:chat_flow}
}

На этапе проектирования была предусмотрена возможность наполнения базы вопросов через интерфейс администратора. Как показано на рисунке \ref{fig:admin_flow}, архитектура реализует проверку прав пользователя при запуске. При наличии административных прав активируется специальный экран, где можно вводить новые карточки. Таким образом, архитектура поддерживает разграничение ролей и безопасную изоляцию функционала.

{
	\centering
	\includegraphics[width=0.9\linewidth]{admin_flow.jpg}
	\captionof{figure}{Логика доступа к административной панели}
	\label{fig:admin_flow}
}

Итоговая архитектура мобильного приложения представляет собой иерархическую структуру, основанную на пользовательских сценариях:

\begin{itemize}
	\item экраны входа и регистрации — проверка подлинности;
	\item экран профиля — просмотр и редактирование данных;
	\item интерфейс вопросов — сбор данных для рекомендаций;
	\item рекомендации — выдача и фильтрация результатов;
	\item запросы на чат и чаты — коммуникация между пользователями;
	\item панель администратора — внутренняя поддержка наполнения базы.
\end{itemize}

Каждый из компонентов был спроектирован с учётом независимости, повторного использования и расширяемости. Такая архитектура обеспечивает устойчивость к росту функциональности и позволяет легко интегрировать рекомендательные алгоритмы на стороне сервера без необходимости внесения значительных изменений в клиентское приложение.

\subsection{Проектирование архитектуры серверной части}

Проектирование серверной части приложения для знакомств начинается с определения ключевых требований к системе. В первую очередь, необходимо обеспечить надёжное взаимодействие с мобильным клиентом, реализацию бизнес-логики приложения, управление пользовательскими данными, хранение медиафайлов, поддержку масштабируемой подсистемы рекомендаций, а также гибкость при развёртывании и сопровождении.

Для обмена данными между клиентским и серверным слоями требуется простой, расширяемый и широко поддерживаемый протокол. Учитывая эти факторы, архитектура взаимодействия строится на основе REST. Это решение обеспечивает стандартизованный обмен информацией через HTTP, совместимость с мобильными платформами и широкую поддержку в инструментах автоматизации.

При проектировании интерфейсов важно предусмотреть их документирование и проверку. Для этих целей подходит спецификация OpenAPI, поддерживающая автоматическую генерацию описания REST-эндпоинтов. Интеграция со Swagger позволяет предоставить наглядную, интерактивную документацию, упрощающую как разработку, так и тестирование API.

Серверная часть должна хранить структурированные пользовательские данные, такие как анкеты, результаты тестов, предпочтения, заявки на чат. Все эти данные обладают чёткой схемой и требуют транзакционной целостности. Поэтому в качестве основной системы управления базами данных обоснован выбор реляционной СУБД. Среди доступных решений наиболее оптимальным по сочетанию стабильности, расширяемости и соответствию промышленным стандартам является PostgreSQL. Эта СУБД поддерживает богатый набор функций, включая работу с JSON, индексацию, расширения, и хорошо интегрируется с инструментами миграций.

Поддержка непрерывного развития и возможность безопасного обновления схемы базы данных требует внедрения системы управления миграциями. Это позволяет отслеживать изменения, выполнять откаты и обеспечивать согласованность структуры данных во всех окружениях. Исходя из популярности, удобства и хорошей интеграции со Spring Boot, в качестве системы миграций выбирается Liquibase.

Поскольку приложение позволяет пользователям загружать изображения профиля и отправлять вложения в чатах, необходимо предусмотреть механизм хранения бинарных данных. Хранение таких файлов непосредственно в базе данных было бы неэффективным и плохо масштабируемым. Вместо этого архитектура должна предусматривать использование объектного хранилища. Оно обеспечивает отдельное хранение медиафайлов с возможностью доступа через HTTP-интерфейс. В качестве подходящего решения выбирается MiniO — объектное хранилище с S3-совместимым API, которое легко разворачивается локально или в облачной среде и обеспечивает высокую отказоустойчивость.

Особое внимание в архитектуре уделяется подсистеме рекомендаций. Она требует специализированной обработки данных, может использовать иные языки программирования, библиотеки машинного обучения, и нуждается в независимом масштабировании. В этой связи было принято решение спроектировать рекомендательную систему как отдельный сервис. Это соответствует принципам микросервисной архитектуры и обеспечивает логическую и техническую изоляцию. Взаимодействие между основной серверной частью и рекомендательным сервисом происходит через HTTP-клиент, реализованный в модуле client.

Общая структура серверного приложения организована на основе модульного подхода с логическим разделением по уровням ответственности. Это упрощает поддержку кода, повышает читаемость и способствует соблюдению принципов SOLID. Каждый модуль отвечает за строго определённую функцию в рамках архитектуры.

Общая структура серверного приложения организована на основе модульного подхода, обеспечивающего логическое разделение по уровням ответственности. Это облегчает поддержку, расширение и тестирование системы.

\begin{itemize}
	\item controller — REST-контроллеры, принимающие HTTP-запросы, валидирующие входные данные и передающие их в бизнес-логику;
	\item service — реализация бизнес-правил, координация взаимодействия между слоями и внешними сервисами;
	\item repository — интерфейсы доступа к базе данных на основе Spring Data JPA;
	\item entity — JPA-сущности, отражающие структуру таблиц и связи между ними;
	\item dto — модели передачи данных между слоями и при взаимодействии с клиентом;
	\item client — модуль HTTP-взаимодействия с внешней рекомендательной системой;
	\item config — конфигурационные классы, включая настройки безопасности, CORS, Swagger и подключение к внешним сервисам;
	\item exception — иерархия пользовательских исключений и глобальная обработка ошибок;
	\item mapper — преобразование между сущностями и DTO;
	\item utils — вспомогательные методы и классы общего назначения.
\end{itemize}

Такое разделение позволяет обеспечить читаемость, переиспользуемость и модульность, а также упрощает интеграцию дополнительных компонентов в архитектуру.


Подобная структура способствует высокой модульности, улучшает читаемость проекта и упрощает тестирование. Чёткое разграничение ответственности между слоями позволяет удобно масштабировать приложение, добавлять новые функции и интегрировать внешние сервисы без нарушения архитектурной целостности.

Для обеспечения воспроизводимости окружения и удобства развертывания на различных машинах проектируется контейнеризированная инфраструктура. Это особенно важно при наличии нескольких сервисов (основного API, рекомендательной системы, базы данных, хранилища медиафайлов). В этих условиях использование Docker становится естественным выбором. С его помощью можно описать каждый компонент как независимый контейнер, настроить их взаимодействие в рамках одной сети и обеспечить надёжное воспроизводимое развёртывание, как в процессе локальной разработки, так и в продуктивной среде.

Таким образом, архитектура серверной части проектируется на основе требований надёжности, масштабируемости и гибкости. В ходе анализа выбираются технологии и подходы, соответствующие поставленным задачам. Итоговая архитектура включает REST-интерфейс, документацию через OpenAPI, использование PostgreSQL с миграциями Liquibase, объектное хранилище MiniO для медиафайлов, отдельный микросервис рекомендаций и контейнеризацию с помощью Docker. Эти решения образуют устойчивую и расширяемую платформу, готовую к дальнейшему развитию.

