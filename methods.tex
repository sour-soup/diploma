% !TeX encoding = windows-1251
\section{Методы построения рекомендательной системы}

\subsection{Коллаборативная фильтрация}

Коллаборативная фильтрация является одним из наиболее популярных подходов в рекомендательных системах, особенно в условиях, когда отсутствует явное описание объектов или пользователей. Основная идея заключается в том, что предпочтения пользователей могут быть предсказаны на основе поведения других пользователей с похожими вкусами.

Существует два основных типа коллаборативной фильтрации: на основе памяти (\emph{memory-based}) и на основе модели (\emph{model-based}). Первый подход использует метрики сходства между пользователями или объектами (например, косинусное расстояние, корреляцию Пирсона) и агрегирует оценки соседей. Второй — строит параметризованную модель на основе данных о взаимодействиях, чаще всего через факторизацию матрицы.

Пусть имеется матрица взаимодействий $R \in \mathbb{R}^{m \times n}$, где $m$ — количество пользователей, $n$ — количество объектов (например, анкет потенциальных партнёров). Элемент $r_{u,i}$ может обозначать бинарную оценку (лайк/не лайк), числовой рейтинг или иной сигнал предпочтения. Коллаборативная фильтрация предполагает, что в матрице присутствует скрытая структура, отражающая закономерности во вкусах пользователей.

Одним из распространённых методов является сингулярное разложение (SVD) или его модификации (например, Funk-SVD, ALS), при которых $R$ аппроксимируется как
\[
R \approx U V^{\top},
\]
где $U \in \mathbb{R}^{m \times k}$ и $V \in \mathbb{R}^{n \times k}$ содержат латентные векторы пользователей и объектов соответственно, а $k$ — число латентных признаков. Значение $\hat{r}_{u,i} = U_u \cdot V_i^{\top}$ интерпретируется как предсказанная степень интереса пользователя $u$ к объекту $i$.

Интересным обобщением является применение коллаборативной фильтрации к данным не только о лайках, но и о признаках, таких как ответы пользователей на опросы. В этом случае каждый пользователь представлен тернарным или категориальным вектором, а матрица $Q \in \{-1, 0, 1\}^{m \times p}$ (где $p$ — число вопросов) также может быть факторизована аналогичным способом:
\[
Q \approx U' Z^{\top}.
\]
Полученные векторы могут использоваться для оценки схожести между пользователями, для восстановления пропущенных ответов или как источник признаков для гибридных моделей.

Коллаборативная фильтрация демонстрирует высокую эффективность при наличии большого количества пользовательских взаимодействий, однако страдает от проблемы холодного старта (new user/item problem) и может усиливать популярность одних и тех же объектов, снижая разнообразие рекомендаций.

\subsection{Эвристики: совпадения по ответам, популярность, фильтры}

Эвристические методы в рекомендательных системах основаны на наборе простых правил и предположений, позволяющих быстро и эффективно формировать рекомендации. Несмотря на относительную простоту, такие подходы остаются актуальными, особенно в условиях ограниченности данных или требований к объяснимости.

Одним из базовых эвристических подходов является сравнение пользователей по их ответам на вопросы анкет или опросов. Если ответы представлены в тернарной шкале (например, $-1$ — несогласие, $0$ — нейтрально, $1$ — согласие), то схожесть между пользователями можно оценить по доле совпадающих ответов:
\[
\mathrm{sim}(u,v) = \frac{1}{|P|} \sum_{i \in P} \mathbf{1}(q_{u,i} = q_{v,i}),
\]
где $P$ — множество вопросов, на которые оба пользователя дали ответ. Этот подход применим как в системах знакомств, так и в других областях, где важна совместимость взглядов, предпочтений и интересов.

Другим эвристическим приёмом является использование показателя популярности. Объекты (например, профили или товары), получившие наибольшее количество положительных оценок, могут предлагаться новым пользователям в качестве стартовых рекомендаций. Популярность может быть нормирована, например:
\[
\mathrm{pop}(i) = \frac{\text{число лайков объекта } i}{\text{максимальное число лайков среди всех объектов}}.
\]
Популярные рекомендации часто дополняются фильтрацией по демографическим и другим признакам, таким как возраст, пол, географическое местоположение, язык, наличие общих интересов и т. д.

Такие фильтры применяются до или после основного ранжирования и позволяют исключить очевидно нерелевантные варианты. Например, пользователь, заинтересованный только в кандидатах определённого возраста или пола, должен получать только соответствующие предложения.

Также может применяться эвристика совпадения по ключевым признакам. Если в профиле пользователя указаны предпочтения (например, любимые фильмы, занятия, взгляды), система может искать совпадения с другими профилями и ранжировать их по количеству совпавших интересов.

Комбинирование эвристик позволяет построить гибкую систему, способную адаптироваться к условиям отсутствия данных, начальной загрузки, а также повысить обоснованность рекомендаций. При этом эвристические методы легко интерпретируемы, что важно в чувствительных сферах, таких как онлайн-знакомства или подбор персонала.


\subsection{Кластеризация (k-means, DBSCAN) и применение в рекомендациях}

Кластеризация — это метод обучения без учителя, направленный на группировку объектов в кластеры таким образом, чтобы элементы одного кластера были похожи друг на друга и отличались от элементов других кластеров. В контексте рекомендательных систем кластеризация применяется для:
\begin{itemize}
	\item сегментирования пользователей (или объектов) по интересам, поведению или признакам;
	\item повышения масштабируемости рекомендаций за счёт ограничения поиска релевантных кандидатов внутри кластера;
	\item выявления нишевых предпочтений и персонализированных паттернов.
\end{itemize}

Одним из наиболее популярных алгоритмов является \emph{k-means}. Он принимает на вход число кластеров $k$ и итеративно минимизирует внутрикластерную дисперсию:
\[
\sum_{j=1}^{k} \sum_{x_i \in C_j} \|x_i - \mu_j\|^2,
\]
где $C_j$ — кластер, а $\mu_j$ — его центр. Алгоритм эффективен при компактных и сферических кластерах, но чувствителен к выбору $k$ и неустойчив к выбросам.

Для более гибкой кластеризации используется алгоритм \emph{DBSCAN} (Density-Based Spatial Clustering of Applications with Noise). Он группирует точки по плотности: кластером считается связная по плотности область, где каждая точка имеет хотя бы $minPts$ соседей в пределах радиуса $\varepsilon$. DBSCAN способен находить кластеры произвольной формы и автоматически игнорирует шум (выбросы), что делает его особенно полезным в гетерогенных данных.

В рекомендательных системах кластеризация применяется по-разному:
\begin{itemize}
	\item На пространстве пользователей: сегментация по поведенческим или опросным признакам позволяет формировать кластеры пользователей с похожими предпочтениями. Рекомендации для нового пользователя можно извлекать из наиболее близкого кластера.
	\item На пространстве объектов: группировка товаров, фильмов, анкет и пр. по тематике, стилю или целевой аудитории позволяет адаптировать рекомендации к интересам пользователя.
	\item В латентных пространствах: кластеризация векторов после факторизации (например, в SVD или autoencoder-подходах) даёт более сжатое и семантически значимое представление.
\end{itemize}

Кластеризация также применяется для визуализации и анализа структуры пользовательской базы, выявления целевых групп и построения тематических подборок. Её эффективность во многом зависит от выбора признаков и масштабов данных, поэтому нередко она используется в комбинации с другими методами.

\subsection{Стратегии холодного старта}

Проблема холодного старта возникает, когда система не располагает достаточной информацией о пользователях или объектах, чтобы формировать персонализированные рекомендации. Выделяют два основных сценария: появление нового пользователя и добавление нового объекта (например, анкеты).

Для новых пользователей могут применяться следующие подходы:

\begin{itemize}
	\item заполнение вступительных тестов или анкет — позволяет собрать первичные признаки и использовать их при формировании рекомендаций;
	\item использование демографических данных — рекомендации подбираются на основе поведения пользователей с аналогичными характеристиками (возраст, пол, география и т.д.);
	\item показ популярных объектов — временная стратегия, при которой пользователю демонстрируются анкеты с высокой оборачиваемостью, что помогает быстрее сформировать профиль предпочтений.
\end{itemize}

При появлении новых объектов, которые ещё не получили откликов, возможны такие меры:

\begin{itemize}
	\item временное повышение приоритета в выдаче — например, показ новым или активным пользователям для ускоренного накопления статистики;
	\item использование признаков схожести — на основе анкетных данных, внешности (в случае CV), текста описания (в случае NLP) или ответов на вопросы;
	\item размещение в релевантных сегментах — объект может быть временно включён в выдачу по кластерам, в которые он потенциально попадает по признаковому пространству.
\end{itemize}

Кроме того, существуют универсальные стратегии, применимые и к новым пользователям, и к новым объектам:

\begin{itemize}
	\item инициализация признаков с помощью доступных внешних данных — анкет, биографий, метаинформации;
	\item использование гибридных моделей, сочетающих элементы content-based и коллаборативной фильтрации — это снижает чувствительность к отсутствию истории;
	\item активное обучение — выбор контента, максимально полезного для уточнения предпочтений, что позволяет за минимальное число взаимодействий улучшить качество рекомендаций.
\end{itemize}

Проблема холодного старта наиболее критична для систем, основанных на коллаборативной фильтрации, поскольку они требуют исторических данных о взаимодействии пользователей с объектами. Поэтому многие современные решения строятся с использованием дополнительных эвристик и предварительной инициализации признаков, что позволяет обеспечить устойчивость системы на ранних этапах использования.

\subsection{Методы глубокого обучения в рекомендательных системах}

Развитие нейросетевых архитектур оказало существенное влияние на область рекомендательных систем. Благодаря способности извлекать сложные латентные зависимости из разнородных данных, модели глубокого обучения применяются для повышения качества рекомендаций как в традиционных задачах (например, предсказание рейтингов), так и в более сложных сценариях, включая мультимодальные рекомендации, учет временной динамики и персонализацию на основе контекста.

Одним из первых направлений стало расширение классической матричной факторизации с помощью нейронных сетей. Вместо простой линейной факторизации матрицы взаимодействий $R \in \mathbb{R}^{m \times n}$, где $m$ — количество пользователей, $n$ — количество объектов, и $R_{ij}$ — факт взаимодействия, используются обучаемые эмбеддинги и нелинейные функции активации. Примером такой модели является Neural Collaborative Filtering (NCF), предложенная в \cite{he2017neural}. В NCF пары эмбеддингов $(\mathbf{u}_i, \mathbf{v}_j)$ передаются через многослойный перцептрон:

\[
\hat{r}_{ij} = \mathrm{MLP}([\mathbf{u}_i, \mathbf{v}_j]),
\]

где $[\cdot, \cdot]$ обозначает конкатенацию векторов. Модель обучается по функции потерь, например, бинарной кросс-энтропии в задаче предсказания лайка/дизлайка.

Другое направление связано с использованием рекуррентных и трансформерных архитектур для моделирования последовательности взаимодействий. Так называемые sequence-based recommenders учитывают порядок взаимодействий пользователя с объектами. Например, модель GRU4Rec \cite{hidasi2015session} применяет Gated Recurrent Unit (GRU) для обработки истории действий пользователя. Базовая идея заключается в следующем: пусть $x_1, x_2, \dots, x_T$ — последовательность взаимодействий, тогда на каждом шаге рассчитывается скрытое состояние $h_t$:

\[
h_t = \mathrm{GRU}(x_t, h_{t-1}),
\]

и предсказывается следующий элемент $x_{t+1}$ с помощью softmax-слоя.

Для учёта более длинных зависимостей и параллельной обработки была предложена модель SASRec \cite{kang2018self}, основанная на self-attention. В отличие от рекуррентных моделей, здесь используется позиционно-кодированная последовательность эмбеддингов, проходящая через слои трансформера. Это позволяет учитывать контекст всех предыдущих действий при выборе следующей рекомендации.

Особое место занимают графовые нейронные сети, применяемые для моделирования взаимодействий в виде графов. В Graph Convolutional Matrix Completion (GC-MC) \cite{berg2017graph}, каждый пользователь и объект представляются вершинами, соединёнными ребром при наличии взаимодействия. Представления вершин обновляются по правилу:

\[
\mathbf{h}_i^{(l+1)} = \sigma\left( \sum_{j \in \mathcal{N}(i)} \frac{1}{c_{ij}} W^{(l)} \mathbf{h}_j^{(l)} \right),
\]

где $\mathcal{N}(i)$ — соседи вершины $i$, $W^{(l)}$ — матрица весов на $l$-м слое, $c_{ij}$ — коэффициент нормализации. Такой подход позволяет учитывать структуру взаимодействий и взаимосвязь объектов, что особенно актуально для задач, где важны не только пользовательские предпочтения, но и социальные или контекстные связи.

Ещё одно активно развивающееся направление — мультимодальные рекомендации. Здесь помимо взаимодействий учитываются дополнительные признаки, такие как текст описания, изображения, аудио. Для обработки таких данных применяются CNN, BERT и другие специализированные архитектуры. В модели VBPR \cite{he2016vbpr} визуальные признаки изображений используются для расширения латентного пространства:

\[
\hat{r}_{ij} = \mathbf{u}_i^\top \mathbf{v}_j + \mathbf{u}_i^\top E x_j,
\]

где $x_j$ — визуальный вектор, полученный из изображения объекта, $E$ — обучаемая матрица проекции.

Основные преимущества методов глубокого обучения:

\begin{itemize}
	\item способность моделировать сложные нелинейные зависимости между пользователями и объектами;
	\item возможность использовать разнородные источники информации;
	\item высокая гибкость и расширяемость архитектур.
\end{itemize}

Тем не менее, существуют и ограничения:

\begin{itemize}
	\item высокая требовательность к вычислительным ресурсам;
	\item потребность в большом объёме размеченных данных;
	\item трудность интерпретации и объяснимости результатов.
\end{itemize}

Таким образом, методы глубокого обучения открывают широкие перспективы для построения более точных и персонализированных рекомендательных систем, особенно в условиях, когда доступны дополнительные источники информации и достаточно ресурсов для обучения. Однако выбор таких подходов должен быть обоснован задачами проекта, размером аудитории и доступной инфраструктурой.


%\subsection{Обоснование выбора подхода}